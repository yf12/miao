<script>
    class PriorityQueue {
        constructor() {
            this.elements = []
        }

        _swap(i,j) {
            var t = this.elements[i]
            this.elements[i] = this.elements[j]
            this.elements[j] = t
        }

        push(val) {

        }

        pop() {
            var result = this.elements[0]
            var last = this.elements.pop()
            this.elements[0] = last

            var currIdx = 0
            var maxIdx = 0
            var lIdx = maxIdx * 2 + 1
            var rIdx = lIdx + 1
            if(lIdx < this.elements.length && this.elements[lIdx] > this.elements[maxIdx]) {
                maxIdx = lIdx
            }
            if(rIdx < this.elements.length && this.elements[rIdx] > this.elements[maxIdx]) {
                maxIdx = rIdx
            }
        }

        //适用于堆尾增加了一个元素时
        //从下往上调整
        headUp(idx) {
            if(idx > 0) {
                var pIdx = (idx - 1) >> 2   //idx元素父元素的下标
                if(this.elements[idx] > this.elements[pIdx]) {
                    this._swap(idx,pIdx)
                    this.headUp(pIdx)
                } else {
                    return
                }
            }
        }

    //从某个位置(currIdx)开始向下调整
    //适用于堆顶删除了一个元素时
    //堆尾的元素补在了堆顶时
        headDown(currIdx) {
            if(currIdx < this.elements.length) {
                var maxIdx = currIdx
                var lIdx = currIdx * 2 + 1
                var rIdx = lIdx + 1
                if(lIdx < this.elements.size && this.elements[maxIdx] < this.elements[lIdx]) {
                    maxIdx = lIdx
                }
                if(rIdx < this.elements.size && this.elements[maxIdx] < this.elements[rIdx]) {
                    maxIdx = rIdx
                }
                if(currIdx != maxIdx) {
                    this._swap(currIdx,maxIdx)
                    this.headDown(maxIdx)
                }
            }
        }
    }
</script>