<script>  //数组转二叉树
    function ary2tree(ary,rootPos = 0) {
        if(ary[rootPos] == null) return null
        var root = {
            val: ary[rootPos],
            left:ary2tree(ary,rootPos * 2 + 1),
            right:ary2tree(ary,rootPos * 2 + 2)
        }
        return root
    }    
</script>

<script>
    function TreeNode(val) {
        this.val = val;
        this.left = this.right = null;
    }
</script>

<script>
var isSameTree = function(p, q) {

    if(!p && !q) return true
    if(!p || !q) return false
    var judge = true
    var isSame = function(p,q) {
        if(p.val == q.val) {
            if(p.left && q.left) {
                isSame(p.left,q.left)
            } 
            if(p.right && q.right) {
                isSame(p.right,q.right)
            }
            if((!(p.left && q.left)) && (!(p.right && q.right)) && (!(!p.left && !p.right && !q.left && !q.right))) {
                judge = false
                return                   
            }
            if(((p.left && q.left) && (!(p.right && q.right))) || ((p.right && q.right) && (!(p.left && q.left)))) {
                judge = false
                return                  
            }
        } else {
            judge = false
            return
        }
    }
    isSame(p,q)
    if(judge) return true
    else return false
}
    isSameTree(ary2tree([1,null,3]),ary2tree([1,2,3]))
</script>

<script>
    var isSameTree = function(p, q) {
        if(!p && !q) return true
        if(!p || !q) return false
        if(p.val == q.val) {
            return (isSameTree(p.left,q.left) && isSameTree(p.right,q.right))
        } else {
            return false
        }
    }
</script>

<script>  //二叉树的最大深度  104
    var maxDepth = function(root) {
        if(root) {
            return 1 + Math.max(maxDepth(root.left),maxDepth(root.right))
        }
        return 0
    }
</script>

<script>  //二叉树的最小深度  111
    var minDepth = function(root) {
        if(!root) return 0
        if(!root.left && !root.right) return 1
        if(!root.right) return 1 + minDepth(root.left)
        if(!root.left) return 1 + minDepth(root.right)
        return 1 + Math.min(minDepth(root.left),minDepth(root.right))
    }
</script>

<script>   //反转树   226
    var invertTree = function(root) {
        if(!root) return null
        if(!root.left && !root.right) return root
        var left = invertTree(root.right)   //注意不能直接root.left = invertTree(root.right)，括号里的是转过的值
        var right = invertTree(root.left)
        root.left = left
        root.right = right
        return root
    }
</script>

<script>   //反转树   226
    var invertTree = function(root) {
        if(root) {
            var left = invertTree(root.right)   //注意不能直接root.left = invertTree(root.right)，括号里的是转过的值
            var right = invertTree(root.left)
            root.left = left
            root.right = right
        }
        return root
    }
</script>

<script>  //合并两棵二叉树  617
    var mergeTrees = function(t1, t2) {

        if(!t1 && !t2) return null
        if(!t1 && t2){
            t1 = t2
            return t1
        }
        if(t1 && ! t2) return t1
        if(t1 && t2) {
            t1.val = t1.val + t2.val
        }
        mergeTrees(t1.left,t2.left)
        mergeTrees(t1.right,t2.right)
        return t1
    }
    mergeTrees(ary2tree([1,3,2,5]),ary2tree([]))
</script>

<script>
    var mergeTrees = function(t1, t2) {
        if(!t1 && !t2) return null
        if(!t1 && t2){
            t1 = t2
            return t1
        }
        if(t1 && ! t2) return t1
        if(t1 && t2) {
            t1.val = t1.val + t2.val
            t1.left = mergeTrees(t1.left,t2.left)
            t1.right = mergeTrees(t1.right,t2.right)
            return t1
        }
    }
</script>

<script>  //合并两棵二叉树  617
    var mergeTrees = function(t1, t2) {
        if(!t1 && !t2) return null
        if(!t1 && t2){
            t1 = t2
            return t1
        }
        if(t1 && ! t2) return t1
        if(t1 && t2) {
            var root = new TreeNode(t1.val + t2.val)
            root.left =  mergeTrees(t1.left,t2.left)
            root.right = mergeTrees(t1.right,t2.right)
            return root
        }
    }
</script>

<script>  //合并两棵二叉树  617
    var mergeTrees = function(t1, t2) {
        if(!t1 && !t2) return null
        if(!t1) return t2
        if(!t2) return t1
        var root = new TreeNode(t1.val + t2.val)
        root.left =  mergeTrees(t1.left,t2.left)
        root.right = mergeTrees(t1.right,t2.right)
        return root
    }
</script>

<script>
    var hasPathSum = function(root, sum) {
        function treeSum(root) {
            if(root.val == sum) return true
            else if(root.val < sum) return root.val + treeSum(root.left) || root.val + treeSum(root.right)
            return false
        }
        if(treeSum(root)) return true
        else return false
    }
</script>

<script>   //树转字符串 606
    var tree2str = function(t) {
        var string = ''
        if(!t) return string
        if(!t.left && !t.right) return string + t.val
        if(t.left && !t.right) return string + t.val + '(' + tree2str(t.left) +')'
        return string + t.val + '(' + tree2str(t.left) +')' + '(' + tree2str(t.right) +')'
    }
</script>

<script>  //101 回文树
    var isSymmetric = function(root) {
        if(!root) return true
        return isSymme(root.left,root.right)
    }

    var isSymme = function(left,right) {
        if(!left || !right) return left == right
        if(left.val != right.val) return false
        return isSymme(left.left,right.right) && isSymme(left.rgiht,right.left)
    }
    isSymmetric(ary2tree[1,2,2,3,3,4,3])
</script>

<script>   //有序树 增加节点 701
    var insertIntoBST = function(root, val) {
        if(!root) return new TreeNode(val)
        if(root.val >= val) {
            root.left = insertIntoBST(root.left,val)
        } else {
            root.right = insertIntoBST(root.right,val)
        }
        return root
    }
</script>

<script>
    var sumOfLeftLeaves = function(root) {
        if(!root) return 0
        if(!root.left && !root.right) return 0
        if(!root.left) return sumOfLeftLeaves(root.right)
        if(root.left && !root.left.left && root.left.right) return sumOfLeftLeaves(root.right)
        if(root.left && !root.left.left && !root.left.right) return root.left.val + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right)
        if(root.left && root.left.left) return sumOfLeftLeaves(root.left)
    }
</script>

<script>   //二叉树 左边叶子和 404
    var sumOfLeftLeaves = function(root) {
        if(!root) return 0
        var sum = 0
        if(root.left) {
            if(!root.left.left && !root.left.right) sum += root.left.val
            else sum += sumOfLeftLeaves(root.left)
        }
        sum += sumOfLeftLeaves(root.right)
        return sum
    }
</script>

<script>  //二叉树 左边叶子和 404
    var sumOfLeftLeaves = function(root) {
        if(!root) return 0
        if(root.left && !root.left.left && !root.left.right) {
            return root.left.val + sumOfLeftLeaves(root.right)
        } else {
            return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right)
        }
    }
</script>

<script>  //二叉树 左边叶子和 404  思路清奇
    var sumOfLeftLeaves = function(root,side) {
        if(!root) return 0
        if(isLeafNode(root) && side == 'l') {
            return root.val
        }
        return sumOfLeftLeaves(root.left,'l') + sumOfLeftLeaves(root.right,'r')
    }
    function isLeafNode(root) {
        return root && !root.left && !root.right
    }
</script>

<script>   //n叉树 最大深度
    var maxDepth = function(root) {
        if(!root) return 0
        let max = 0
        root.children.forEach(it => {
            max = Math.max(max,maxDepth(it))
        })
        return max + 1
    }
</script>

<script>   //前中序求树  105
    var buildTree = function(preorder, inorder) {
        if(preorder.length == 0) return null
        let t = preorder[0]
        let idx = inorder.indexOf(t)
        let leftinorder = inorder.slice(0,idx)
        let rightinorder = inorder.slice(idx + 1)
        let leftpreorder = preorder.slice(1,leftinorder.length + 1)
        let rightpreorder = preorder.slice(leftinorder.length + 1)
        let root = new TreeNode(t)
        root.left = buildTree(leftpreorder,leftinorder)
        root.right = buildTree(rightpreorder,rightinorder)
        return root
    }
    buildTree([3,9,20,15,7],[9,3,15,20,7])
</script>

<script>  //二叉树按深度分数组 102
    var levelOrder = function(root) {
        let result = []
        let d = -1
        function traverse(root) {
            d++
            if(root) {
                if(d in result) {
                    result[d].push(root.val)
                } else {
                    result[d] = [root.val]
                }
                traverse(root.left)
                traverse(root.right)
            }
            d--
        }
        traverse(root)
        return result
    }
</script>

<script>  //二叉树按深度分数组 102  用到了参数默认值
    var levelOrder = function(root,result = [],depth = 0) {
        if(root) {
            if(depth in result) {
                result[depth].push(root.val)
            } else {
                result[depth] = [root.val]
            }
            levelOrder(root.left,result,depth + 1)
            levelOrder(root.right,result,depth + 1)    
        }
        return result
    }
</script>

<script>   //二叉树按深度分数组 102  栈的思想
    var levelOrder = function(root) {
        let result = []
        let row = [root]
        let nextRow = []
        let rowValues = []
        let node
        while(node = row.shift()) {
            rowValues.push(node.val)
            if(node.left) {
                nextRow.push(node.left)
            }
            if(node.right) {
                nextRow.push(node.right)
            }
            if(row.length == 0) {
                result.push(rowValues)
                row = nextRow
                nextRow = []
                rowValues = []
            }
        }
        return result
    }
</script>

<script>   //有序树 删除节点 450
    var deleteNode = function(root, key) {
        if(!root) return root
        if(key < root.val) {
            root.left = deleteNode(root.left,key)
            return root
        }
        if(key > root.val) {
            root.right = deleteNode(root.right,key)
            return root
        }
        if(key == root.val) {
            if(!root.left && !root.right) return null
            if(!root.left) return root.right
            if(!root.right) return root.left
            if(isLeafNode(root.left)) {
                root.val = root.left.val
                root.left = null
                return root
            } else {
                let leftMax = getMaxNode(root.left)  //节点
                root.val = leftMax.val
                root.left = deleteNode(root.left,leftMax.val)
                return root
            }
        }
    }

    function getMaxNode(root) {    //左边树最大（或右边树最小）一定是左边树最右侧的叶子节点
        while(root.right) {
            root = root.right
        }
        return root
    }

    function isLeafNode(node) {
        return !node.left && !node.right
    }
</script>

<script>
    var serialize = function(root) {
        var string = ''
        if(!root) return string
        if(!root.left && !root.right) return string + root.val
        if(root.left && !root.right) return string + root.val + '(' + serialize(root.left) +')'
        return string + root.val + '(' + serialize(root.left) +')' + '(' + serialize(root.right) +')'
    }
    serialize([1,2,3,null,null,4,5])
</script>

<script>
    var deserialize = function(data,result = []) {
        if(data = '(') return result
        let breakpoint
        for(let i = 2;i < data.length;i++) {
            let stack = []
            if(data[i] = '(') {
                stack.push(data[i])
            }
            if(data[i] == ')') {
                if(stack.length == 0) {
                    breakpoint = i
                    break
                } else {
                    stack.pop()
                }
            }
        }
        result.push(data[0],data[2],data[breakpoint + 2])
        data1 = data.slice(2,breakpoint)
        data2 = data.slice(breakpoint + 2,data.length - 1)
        deserialize(data1,result)
        deserialize(data2,result)
        return result
    }
    deserialize("1(2(4(8)(9))(5))(3(6)(7))")
</script>

<script>  //938
    var rangeSumBST = function(root, L, R, status={sum:0, judge:false}) {
        if(!root) return 0
        if(root.left) {
            rangeSumBST(root.left,L,R,status)
        }
        if(root.val == L) {
            status.judge = true
        }
        if(root.val == R) {
            status.sum += root.val
            status.judge = false
            return sum
        }
        if(status.judge) {
            status.sum += root.val
        }
        if(root.right) {
            rangeSumBST(root.right,L,R,status)
        }
        return status.sum
    }
    rangeSumBST(lcary2tree([10,5,15,3,7,null,18]),7,15)
</script>

<script>  //235
    var lowestCommonAncestor = function(root, p, q) {
        var min = Math.min(p.val,q.val)
        var max = Math.max(p.val,q.val)
        if(!root) return root
        if(root.val == max || root.val == min) {
            return root
        } else if(root.val > max) {
            return lowestCommonAncestor(root.left,p,q)
        } else if(root.val < max){
            if(root.val > min) {
                return root
            } else if(root.val < min) {
                return lowestCommonAncestor(root.right,p,q)
            }
        }
    }
    lowestCommonAncestor(lcary2tree([6,2,8,0,4,7,9,null,null,3,5]),7,3)
</script>

<script> //236
    var lowestCommonAncestor = function(root, p, q) {
        if(!root) return root
        if(p.val == root.val || q.val == root.val) {
            return root
        } else if(isInit(root.left,p.val) !== isInit(root.left,p.val)) {
            return root
        } else if(isInit(root.left,p.val) == 1 && isInit(root.left,q.val) == 1) {
            return lowestCommonAncestor(root.left,p,q)
        } else if(isInit(root.left,p.val) == 0 && isInit(root.left,q.val) == 0) {
            return lowestCommonAncestor(root.right,p,q)
        }
    }
    lowestCommonAncestor(lcary2tree([3,5,1,6,2,9,8,null,null,7,4]))

    function isInit(root,value,judge = 0) {
        if(root) {
            if(root.val == value) {
                judge = 1
                return judge
            }
            judge = isInit(root.left,value,judge)
            judge = isInit(root.right,value,judge)
        }
        return judge
    }
</script>

<script>  //236 标准解法【大概
    var lowestCommonAncestor = function(root, p, q) {
        if(!root || root == p || root == q) {
            return root
        }
        var l = lowestCommonAncestor(root.left,p,q)
        var r = lowestCommonAncestor(root.right,p,q)

        if(l && r) return root
        if(!l && ! r) return null
        return l ? l : r
    }
    lowestCommonAncestor(lcary2tree([3,5,1,6,2,0,8,null,null,7,4]),7,0)
</script>

<script>
    var isValidBST = function(root,flag = true) {
        if(!root) return true
        if(root) {
            if(root.left) {
                if(root.left.val >= root.val) {
                    return false
                }
            }
            if(root.right) {
                if(root.right.val <= root.val) {
                    return false
                }
            }
        }
        if(root.left) return isValidBST(root.left)
        if(root.left) return isValidBST(root.right)
        return true
    }
</script>

<script>
    var isValidBST = function(root) {
        if(!root) return true
        if(root.left) isValidBST(root.left)
        if(root.left) {
            if(root.left.val >= root.val) {
                return false
            }
        }
        if(root.right) {
            if(root.right.val <= root.val) {
                return false
            }
        }
        if(root.left) return isValidBST(root.right)        
    }
</script>

<script>
    var isValidBST = function(root) {
        if(!root) return true
        if(root.left) {
            if(root.left.val >= root.val) {
                return false
            }
            if(root.left.left) {
                if(root.left.left.val >= root.left.val) {
                    return false
                }
            }
            if(root.left.right) {
                if(root.left.right.val <= root.left.val) {
                    return false
                }
                if(root.left.right.val >= root.val) {
                    return false
                }
            }
        }
        if(root.right) {
            if(root.right.val <= root.val) {
                return false
            }
            if(root.right.left) {
                if(root.right.left.val >= root.right.val) {
                    return false
                }
                if(root.right.left.val <= root.val) {
                    return false
                }
            }
            if(root.right.right) {
                if(root.right.right.val <= root.right.val) {
                    return false
                }
            }
        }
        if(root.left) return isValidBST(root.left)
        if(root.left) return isValidBST(root.right)
        return true
    }

</script>

<script>  //判断是否是BST 98
    var isValidBST = function(root) {
        if(!root) return true
        let stack = []
        let pre = new TreeNode()
        while(root || stack.length > 0) {
            while(root) {
                stack.push(root)
                root = root.left
            }
            root = stack.pop()
            if(pre && root.val <= pre.val) {
                return false
            }
            pre = root
            root = root.right
        }
        return true
    }
    isValidBST(lcary2tree([3,1,5,0,2,4,6,null,null,null,3]))
</script>

<script>  //二叉树中序遍历  94 循环 栈
    var inorderTraversal = function(root) {
        let result = []
        let stack = []
        while(root || stack.length > 0) {
            if(root) {
                stack.push(root)
                root = root.left
            }
            root = stack.pop()
            result.push(root.val)
            root = root.right
        }
        return result
    }
    inorderTraversal(lcary2tree([3,1,5,0,2,4,6,null,null,null,3]))
</script>

<script>   //二叉树中序遍历 递归 ...
    var inorderTraversal = function(root) {
        let result = []
        if(root) {
            if(root.left) {
                result.push(...inorderTraversal(root.left))
            }
            result.push(root.val)
            if(root.right) {
                result.push(...inorderTraversal(root.right))
            }
        }
        return result
    }
</script>

<script>   //230
    var kthSmallest = function(root, k) {
        let stack = []
        let count = 0
        while(root || stack.length > 0) {
            while(root) {
                stack.push(root)
                root = root.left
            }
            root = stack.pop()
            count++
            if(count == k) {
                return root.val
            }
            root = root.right
        }
    }
</script>

<script>  //判断是否是平衡树  110
    var isBalanced = function(root) {
        return balance(root) >= 0
    }

    //如果root是平衡的，返回其深度
    //如果不是，返回-1
    function balance(root) {
        if(root) {
            var dl = balance(root.left)
            var dr = balance(root.right)
            if(dl == -1 || dr == -1) {
                return -1
            }
            if(Math.abs(dl - dr) <= 1) {
                return Math.max(dl,dr) + 1
            } else {
                return -1
            }
        }
        return 0
    }
</script>

<script>  //BST节点的最小差值 783
    var minDiffInBST = function(root) {
        if(root) {
            if(root.left) {
                var left = root.left
                while(left.right) {
                    left = left.right
                }
                var lval = root.val - left.val
            }
            if(root.right) {
                var right = root.right
                while(right.left) {
                    right = right.left
                }
                var rval = right.val - root.val
            }
            lval = lval ? lval : Infinity
            rval = rval ? rval : Infinity
            var l = root.left ? minDiffInBST(root.left) : Infinity
            var r = root.right ? minDiffInBST(root.right) : Infinity
            return Math.min(lval,rval,l,r)
        }
    }
    minDiffInBST(lcary2tree([96,12,null,null,13,null,52,29,null,null,null]))
</script>

<script>
    var lowestCommonAncestor = function(root, p, q) {
        if(!root) return 0
        if(!root.left && !root.right) {
            if(root == p || root == q) {
                return 1
            } else {
                return 0
            }
        }
        let ls = lowestCommonAncestor(root.left,p,q)
        let rs = lowestCommonAncestor(root.right,p,q)
        if(typeof(ls) != 'number') return ls
        if(typeof(rs) != 'number') return rs
        if(rs + ls == 2) return root
        if(root == p || root == q) {
            if(1 + ls + rs == 2) return root
            else return 1
        } else {
            return ls + rs
        }
    }
</script>




    
