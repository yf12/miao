<script>  //数组转二叉树
    function ary2tree(ary,rootPos = 0) {
        if(ary[rootPos] == null) return null
        var root = {
            val: ary[rootPos],
            left:ary2tree(ary,rootPos * 2 + 1),
            right:ary2tree(ary,rootPos * 2 + 2)
        }
        return root
    }    
</script>

<script>
    function TreeNode(val) {
        this.val = val;
        this.left = this.right = null;
    }
</script>

<script>
var isSameTree = function(p, q) {

    if(!p && !q) return true
    if(!p || !q) return false
    var judge = true
    var isSame = function(p,q) {
        if(p.val == q.val) {
            if(p.left && q.left) {
                isSame(p.left,q.left)
            } 
            if(p.right && q.right) {
                isSame(p.right,q.right)
            }
            if((!(p.left && q.left)) && (!(p.right && q.right)) && (!(!p.left && !p.right && !q.left && !q.right))) {
                judge = false
                return                   
            }
            if(((p.left && q.left) && (!(p.right && q.right))) || ((p.right && q.right) && (!(p.left && q.left)))) {
                judge = false
                return                  
            }
        } else {
            judge = false
            return
        }
    }
    isSame(p,q)
    if(judge) return true
    else return false
}
    isSameTree(ary2tree([1,null,3]),ary2tree([1,2,3]))
</script>

<script>
    var isSameTree = function(p, q) {
        if(!p && !q) return true
        if(!p || !q) return false
        if(p.val == q.val) {
            return (isSameTree(p.left,q.left) && isSameTree(p.right,q.right))
        } else {
            return false
        }
    }
</script>

<script>  //二叉树的最大深度  104
    var maxDepth = function(root) {
        if(root) {
            return 1 + Math.max(maxDepth(root.left),maxDepth(root.right))
        }
        return 0
    }
</script>

<script>  //二叉树的最小深度  111
    var minDepth = function(root) {
        if(!root) return 0
        if(!root.left && !root.right) return 1
        if(!root.right) return 1 + minDepth(root.left)
        if(!root.left) return 1 + minDepth(root.right)
        return 1 + Math.min(minDepth(root.left),minDepth(root.right))
    }
</script>

<script>   //反转树   226
    var invertTree = function(root) {
        if(!root) return null
        if(!root.left && !root.right) return root
        var left = invertTree(root.right)   //注意不能直接root.left = invertTree(root.right)，括号里的是转过的值
        var right = invertTree(root.left)
        root.left = left
        root.right = right
        return root
    }
</script>

<script>   //反转树   226
    var invertTree = function(root) {
        if(root) {
            var left = invertTree(root.right)   //注意不能直接root.left = invertTree(root.right)，括号里的是转过的值
            var right = invertTree(root.left)
            root.left = left
            root.right = right
        }
        return root
    }
</script>

<script>  //合并两棵二叉树  617
    var mergeTrees = function(t1, t2) {

        if(!t1 && !t2) return null
        if(!t1 && t2){
            t1 = t2
            return t1
        }
        if(t1 && ! t2) return t1
        if(t1 && t2) {
            t1.val = t1.val + t2.val
        }
        mergeTrees(t1.left,t2.left)
        mergeTrees(t1.right,t2.right)
        return t1
    }
    mergeTrees(ary2tree([1,3,2,5]),ary2tree([]))
</script>

<script>
    var mergeTrees = function(t1, t2) {
        if(!t1 && !t2) return null
        if(!t1 && t2){
            t1 = t2
            return t1
        }
        if(t1 && ! t2) return t1
        if(t1 && t2) {
            t1.val = t1.val + t2.val
            t1.left = mergeTrees(t1.left,t2.left)
            t1.right = mergeTrees(t1.right,t2.right)
            return t1
        }
    }
</script>

<script>  //合并两棵二叉树  617
    var mergeTrees = function(t1, t2) {
        if(!t1 && !t2) return null
        if(!t1 && t2){
            t1 = t2
            return t1
        }
        if(t1 && ! t2) return t1
        if(t1 && t2) {
            var root = new TreeNode(t1.val + t2.val)
            root.left =  mergeTrees(t1.left,t2.left)
            root.right = mergeTrees(t1.right,t2.right)
            return root
        }
    }
</script>

<script>  //合并两棵二叉树  617
    var mergeTrees = function(t1, t2) {
        if(!t1 && !t2) return null
        if(!t1) return t2
        if(!t2) return t1
        var root = new TreeNode(t1.val + t2.val)
        root.left =  mergeTrees(t1.left,t2.left)
        root.right = mergeTrees(t1.right,t2.right)
        return root
    }
</script>

<script>
    var hasPathSum = function(root, sum) {
        function treeSum(root) {
            if(root.val == sum) return true
            else if(root.val < sum) return root.val + treeSum(root.left) || root.val + treeSum(root.right)
            return false
        }
        if(treeSum(root)) return true
        else return false
    }
</script>

<script>   //树转字符串 606
    var tree2str = function(t) {
        var string = ''
        if(!t) return string
        if(!t.left && !t.right) return string + t.val
        if(t.left && !t.right) return string + t.val + '(' + tree2str(t.left) +')'
        return string + t.val + '(' + tree2str(t.left) +')' + '(' + tree2str(t.right) +')'
    }
</script>

<script>  //101 回文树
    var isSymmetric = function(root) {
        if(!root) return true
        return isSymme(root.left,root.right)
    }

    var isSymme = function(left,right) {
        if(!left || !right) return left == right
        if(left.val != right.val) return false
        return isSymme(left.left,right.right) && isSymme(left.rgiht,right.left)
    }
    isSymmetric(ary2tree[1,2,2,3,3,4,3])
</script>

<script>   //有序树 增加节点 701
    var insertIntoBST = function(root, val) {
        if(!root) return new TreeNode(val)
        if(root.val >= val) {
            root.left = insertIntoBST(root.left,val)
        } else {
            root.right = insertIntoBST(root.right,val)
        }
        return root
    }
</script>

<script>
    var sumOfLeftLeaves = function(root) {
        if(!root) return 0
        if(!root.left && !root.right) return 0
        if(!root.left) return sumOfLeftLeaves(root.right)
        if(root.left && !root.left.left && root.left.right) return sumOfLeftLeaves(root.right)
        if(root.left && !root.left.left && !root.left.right) return root.left.val + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right)
        if(root.left && root.left.left) return sumOfLeftLeaves(root.left)
    }
</script>

<script>   //二叉树 左边叶子和 404
    var sumOfLeftLeaves = function(root) {
        if(!root) return 0
        var sum = 0
        if(root.left) {
            if(!root.left.left && !root.left.right) sum += root.left.val
            else sum += sumOfLeftLeaves(root.left)
        }
        sum += sumOfLeftLeaves(root.right)
        return sum
    }
</script>

<script>  //二叉树 左边叶子和 404
    var sumOfLeftLeaves = function(root) {
        if(!root) return 0
        if(root.left && !root.left.left && !root.left.right) {
            return root.left.val + sumOfLeftLeaves(root.right)
        } else {
            return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right)
        }
    }
</script>

<script>  //二叉树 左边叶子和 404  思路清奇
    var sumOfLeftLeaves = function(root,side) {
        if(!root) return 0
        if(isLeafNode(root) && side == 'l') {
            return root.val
        }
        return sumOfLeftLeaves(root.left,'l') + sumOfLeftLeaves(root.right,'r')
    }
    function isLeafNode(root) {
        return root && !root.left && !root.right
    }
</script>

<script>   //n叉树 最大深度
    var maxDepth = function(root) {
        if(!root) return 0
        let max = 0
        root.children.forEach(it => {
            max = Math.max(max,maxDepth(it))
        })
        return max + 1
    }
</script>

<script>   //前中序求树  105
    var buildTree = function(preorder, inorder) {
        if(preorder.length == 0) return null
        let t = preorder[0]
        let idx = inorder.indexOf(t)
        let leftinorder = inorder.slice(0,idx)
        let rightinorder = inorder.slice(idx + 1)
        let leftpreorder = preorder.slice(1,leftinorder.length + 1)
        let rightpreorder = preorder.slice(leftinorder.length + 1)
        let root = new TreeNode(t)
        root.left = buildTree(leftpreorder,leftinorder)
        root.right = buildTree(rightpreorder,rightinorder)
        return root
    }
    buildTree([3,9,20,15,7],[9,3,15,20,7])
</script>

<script>  //二叉树按深度分数组 102
    var levelOrder = function(root) {
        let result = []
        let d = -1
        function traverse(root) {
            d++
            if(root) {
                if(d in result) {
                    result[d].push(root.val)
                } else {
                    result[d] = [root.val]
                }
                traverse(root.left)
                traverse(root.right)
            }
            d--
        }
        traverse(root)
        return result
    }
</script>

<script>  //二叉树按深度分数组 102  用到了参数默认值
    var levelOrder = function(root,result = [],depth = 0) {
        if(root) {
            if(depth in result) {
                result[depth].push(root.val)
            } else {
                result[depth] = [root.val]
            }
            levelOrder(root.left,result,depth + 1)
            levelOrder(root.right,result,depth + 1)    
        }
        return result
    }
</script>

<script>   //二叉树按深度分数组 102  栈的思想
    var levelOrder = function(root) {
        let result = []
        let row = [root]
        let nextRow = []
        let rowValues = []
        let node
        while(node = row.shift()) {
            rowValues.push(node.val)
            if(node.left) {
                nextRow.push(node.left)
            }
            if(node.right) {
                nextRow.push(node.right)
            }
            if(row.length == 0) {
                result.push(rowValues)
                row = nextRow
                nextRow = []
                rowValues = []
            }
        }
        return result
    }
</script>

<script>   //有序树 删除节点 450
    var deleteNode = function(root, key) {
        if(!root) return root
        if(key < root.val) {
            root.left = deleteNode(root.left,key)
            return root
        }
        if(key > root.val) {
            root.right = deleteNode(root.right,key)
            return root
        }
        if(key == root.val) {
            if(!root.left && !root.right) return null
            if(!root.left) return root.right
            if(!root.right) return root.left
            if(isLeafNode(root.left)) {
                root.val = root.left.val
                root.left = null
                return root
            } else {
                let leftMax = getMaxNode(root.left)  //节点
                root.val = leftMax.val
                root.left = deleteNode(root.left,leftMax.val)
                return root
            }
        }
    }

    function getMaxNode(root) {    //左边树最大（或右边树最小）一定是左边树最右侧的叶子节点
        while(root.right) {
            root = root.right
        }
        return root
    }

    function isLeafNode(node) {
        return !node.left && !node.right
    }
</script>
