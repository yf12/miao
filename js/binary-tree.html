<script>
    function ary2tree(ary) {
        k = Math.floor(Math.log2(ary.length)) + 1   //深度
        var head = {
            val:ary[0],
            left:null,
            right:null
        }
        var list1 = head
        var list2 = head
        for(let i = 0;i < k;i++) {
            list1 = list1.left
            list1.left.val = ary[2 * i + 1]
        }
        for(let i = 0;i < k;i++) {
            list2 = list2.right
            list2.right.val = ary[2 * i + 2]
        }
        return head
    }
    ary2tree([1,2,3,null,4,null,5,null,null,7,8,null,null,6])
</script>

<script>  //将根节点在数组rootPos位置的一个由数组表达的二叉树转换为一颗由二叉链表表达的数
    function ary2tree(ary,rootPos = 0) {
        if(ary[rootPos] == null) return null
        var root = {
            val: ary[rootPos],
            left:ary2tree(ary,rootPos * 2 + 1),
            right:ary2tree(ary,rootPos * 2 + 2)
        }
        return root
    }
    ary2tree([1,2,3,null,4,null,5,null,null,7,8,null,null,6])
</script>

<script>  // 将由二叉链表表达的树放回数组，根节点放在pos位置
    function tree2array(root) {
        var result = []
        return tree2ary(root,0)
        function tree2ary(root,pos = 0) {
            if(root) {
                result[pos] = root.val
                tree2ary(root.left,pos * 2 + 1)
                tree2ary(root.right,pos * 2 + 2)
            }
        }
    }
</script>

<script>  // 上面简洁点的写法
    function tree2ary(root,pos = 0,result = []) {
        if(root) {
            result[pos] = root.val
            tree2ary(root.left,pos * 2 + 1,result)
            tree2ary(root.right,pos * 2 + 2,result)
        }
        return result
    }
</script>

<script>  //非完全二叉树
    function lcary2tree(ary) {
        if(ary.length == 0) return null
        var root = {
            val: ary[0],
            left: null,
            right: null
        }
        var nodes = [root]
        for(i = 1;i < ary.length;i++) {
            var curr = nodes.shift()
            if(ary[i] != null) {
                node = {
                    val:ary[i],
                    left: null,
                    right: null
                }
                curr.left = node
                nodes.push(node)
            } else {
                curr.left = null
            }
            i++
            if(i >= ary.length) break 
            if(ary[i] != null) {
                node = {
                    val:ary[i],
                    left: null,
                    right: null
                }
                curr.right = node
                nodes.push(node)
            } else {
                curr.right = null
            }
        }
        return root
    }
    lcary2tree([1,2,null,3,4,null,5,null,null,null,6,7,null,8,9])
</script>

<script>
    function lctree2ary(root) {
        var result = []
        var nodes = [root]
        while(nodes.length) {
            var curr = nodes.shift()
            if(curr) {
                result.push(curr.val)
                nodes.push(curr.left,curr.right)
            } else {
                result.push(null)
            }
        }
        return result
    }
    lctree2ary(lcary2tree([1,2,null,3,4,null,5,null,null,null,6,7,null,8,9]))
</script>

<script>
    function lctree2ary2(root) {
        if(root) {
            var result = [root.val]
            var nodes = [root]
            while(nodes.length) {
                var curr = nodes.shift()
                if(curr.left) {
                    result.push(curr.left.val)
                    nodes.push(curr.left)
                } else {
                    result.push(null)
                }
                if(curr.right) {
                    result.push(curr.right.val)
                    nodes.push(curr.right)
                } else {
                    result.push(null)
                }
            }
        }
        return result
    }
    lctree2ary2(lcary2tree([1,2,null,3,4,null,5,null,null,null,6,7,null,8,9]))

</script>

<script>
    function insertIntoBST(root,val) {
        if(!root) {
            return new TreeNode(val)
        }
        if(val >= root.val) {
            root.right = insertIntoBST(root.right,val)
        }
        else {
            root.left = insertIntoBST(root.left,val)
        } 
        return root
    }
    insertIntoBST(ary2tree([6,3,8,2,4,7,9]),5)
</script>

<script>  //二叉树排序算法
    function bstSort(ary) {
        var root = null
        for(let i = 0;i < ary.length;i++) {
            root = insertIntoBST(root,ary[i])
        }
        k = 0
        inOrderTraverse(root,val => {
            ary[k++] = val
        })
        return ary
    }
</script>

<script>
    function bstSort(ary) {
        var root = ary.reduce(function(root,item) {
            return insertIntoBST(root,item)
        }, null)
        k = 0
        inOrderTraverse(root,val => {
            ary[k++] = val
        })
        return ary
    }
</script>

<script>
    function bstSort(ary) {
        k = 0
        inOrderTraverse(ary.reduce(insertIntoBST(root,item), null),val => {  //要去掉insert函数的(root,item)
            ary[k++] = val
        })
        return ary
    }
</script>

<script>
    function bstSort(ary){
        var root = ary.reduce(insertIntoBST,null)
        k = 0
        inOrderTraverse(root,val => {
            ary[k++] = val
        })
        return ary
    }
</script>