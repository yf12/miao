// average time O(n * log(n))
// worst time O(n * b)
// space O(n)
<script>  //二叉树排序算法
    function bstSort(ary) {
        var root = null
        for(let i = 0;i < ary.length;i++) {
            root = insertIntoBST(root,ary[i])
        }
        k = 0
        inOrderTraverse(root,val => {
            ary[k++] = val
        })
        return ary
    }
</script>

<script>
    function bstSort(ary) {
        var root = ary.reduce(function(root,item) {
            return insertIntoBST(root,item)
        }, null)
        k = 0
        inOrderTraverse(root,val => {
            ary[k++] = val
        })
        return ary
    }
</script>

<script>
    function bstSort(ary) {
        k = 0
        inOrderTraverse(ary.reduce(insertIntoBST(root,item), null),val => {  //要去掉insert函数的(root,item)
            ary[k++] = val
        })
        return ary
    }
</script>

<script>
    function bstSort(ary){
        var root = ary.reduce(insertIntoBST,null)
        k = 0
        inOrderTraverse(root,val => {
            ary[k++] = val
        })
        return ary
    }
</script>

// time O(n * n)
// space O(1)
<script>   //选择排序
    function swap(ary,i,j) {
        if(i !== j) {
            var t = ary[i]
            ary[i] = ary[j]
            ary[j] = t
        }
    }

    function selectSort(ary) {

        for(let i = 0; i < ary.length - 1; i++) {
            let minPos = i
            for(var j = i + 1; j < ary.length; j++) {
                if(ary[j] < ary[minPos]) {
                    minPos = j
                }
            }
            swap(ary,i,minPos)
        }
        return ary
    }
    array = Array(100).fill(0).map(it => Math.random() * 100 | 0)
    selectSort(array)
</script>

<script>
    function partition(ary,start = 0,end = ary.length - 1) {
        let lefti = start - 1,righti = start
        let r = (Math.random * ary.length) | 0
        let t = ary[r]
        ary[r] = ary[end]
        ary[end] = t
        for(let righti = start; righti < end; righti++) {
            if((ary[i] < ary[end]) && ((righti - lefti) == 1)) {
                lefti++
            }
            if((ary[i] < ary[end]) && ((righti - lefti) > 1)){
                t = ary[lefti + 1]
                ary[lefti + 1] = ary[righti]
                ary[righti] = t
                lefti++
            }
        }
        t = ary[lefti]
        ary[lefti] = ary[end]
        ary[end] = t
        partition(ary,0,lefti)
        partition(ary,0,lefti)
        partition(ary,0,lefti)
    } 
</script>

<script> //快排  对所有元素都相同的数组来说，性能会退化到n*n,调用栈会达到n层
    function quickSort(ary,start = 0,end = ary.length - 1) {
        if(k > nums.length || (nums.length == 0)) return -1
        if(end - start <= 0) {
            return ary
        }

        var pivotIndex = Math.floor(Math.random() * (end - start + 1) + start)
        var pivot = ary[pivotIndex]
        swap(ary,pivotIndex,end)

        var i = start - 1
        for(var j = start;j < end;j++) {
            if(ary[j] < pivot) {
                i++
                swap(ary,i,j)
            }
        }
        i++
        swap(ary,i,end)

        quickSort(ary,start,i - 1)
        quickSort(ary,i + 1,end)
        return ary
    }

    function swap(ary,i,j) {
        let t = ary[i]
        ary[i] = ary[j]
        ary[j] = t
    }

    //function quickSort(ary,compare,start = 0,end = ary.length - 1)   //当数组中是对象时通过compare函数来判断顺序，compare返回<0,=0,>0
    //if(compare(ary[j],pivot))
</script>

<script>
    var findKthLargest = function(nums, k) {
        if(k > nums.length) return -1
        if(nums = null) return -1
        let t = nums.length - k
        function partition(ary,start = 0,end = ary.length - 1) {
            let pivotIndex = Math.floor(Math.random() * (end - start + 1) + start)
            let pivot = ary[pivotIndex]        
            swap(ary,pivotIndex,end)

            var i = start - 1
            for(var j = start;j < end;j++) {
                if(ary[j] < pivot) {
                    i++
                    swap(ary,i,j)
                }
            }
            i++
            swap(ary,i,end)
            if(i == t) {
                return ary[i]
            }
            else if(i > t) {
                return partition(ary,start,i - 1)
            }
            else {
                return partition(ary,i + 1,end)
            }
        }

        function swap(ary,i,j) {
            let t = ary[i]
            ary[i] = ary[j]
            ary[j] = t
        } 
        return partition(nums)
    }

    findKthLargest([3,2,1,5,6,4],1)

</script>