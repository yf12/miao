<script type = "x"> //数组转链表 递归 数组过长时栈会爆
    function arrayToList(ary, start = 0) {
        if(start == ary.length) return null
        var headNode = {
            val: ary[start],
            next: arrayToList(ary,++start)   
        }
        return headNode
    }
    arrayToList([0,1,2,3,4])
</script>

<script>
    function ListNode(val) {
        this.val = val
        this.next = null
    }
</script>

<script type = "x"> //141
    var hasCycle = function(head) {
        var slow = head,fast = head
        while(fast !== null && fast.next !== null) {
            slow = slow.next
            fast = fast.next.next
            if(slow == fast) return true
        }
        return false
    }
</script>

<script type = "x">  //链表合并  21
     var mergeTwoLists = function(l1, l2) {

        if(l1 === null || l2 === null) {
            return l1 === null ? l2 : l1
        }
        let merge = new ListNode()
        let l3 = merge
        if(l1.val <= l2.val) {
            l3.val = l1.val
            l1 = l1.next
        } else {
            l3.val = l2.val
            l2 = l2.next           
        }
        while(l1 || l2) {
            if( l2 === null || (l1 != null && l1.val < l2.val)) {  //左边为真返回左边
                l3.next = l1
                l1 = l1.next
            }
            else {
                l3.next = l2
                l2 = l2.next
            }
            l3 = l3.next  
        }
        return merge
    }
    mergeTwoLists(arrayToList([1,2,4]),arrayToList([1,3,4]))
</script>

<script type = "x">  //链表合并  21
    var mergeTwoLists = function(l1, l2) {
        var merge = {val: -1, next: null}
        var prev = merge
        while(l1 && l2) {
            if(l1.val >= l2.val) {
                prev.next = l2
                l2 = l2.next
            } else {
                prev.next = l1
                l1 = l1.next
            }
            prev = prev.next
        }
        prev.next = l1 || l2
        return merge.next
    }
</script>

<script>   //148 列表排序 需要dummy节点,在只有两个元素的时候链表右边为空，会无限递归
    var sortList = function(head) {
        if(!head || !head.next) return head
        var dummy = new ListNode()
        dummy.next = head
        var slow = dummy,fast = dummy
        while(fast && fast.next) {
            slow = slow.next
            fast = fast.next.next
        }
        var left = head,right = slow.next
        slow.next = null
        left = sortList(left)
        right = sortList(right)
        return mergeTwoLists(left,right)
    }

    var mergeTwoLists = function(l1, l2) {
        if(!l1 || !l2) return l1 || l2
        if(l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next,l2)
            return l1
        } else {
            l2.next = mergeTwoLists(l1,l2.next)
            return l2
        }
    }
</script>

<script>//148 列表排序 不需要dummy节点
    var sortList = function(head) {
        if(!head || !head.next) return head
        var slow = head,fast = head
        while(fast.next && fast.next.next) {
            slow = slow.next
            fast = fast.next.next
        }
        var left = head,right = slow.next
        slow.next = null
        left = sortList(left)
        right = sortList(right)
        return mergeTwoLists(left,right)
        }

    var mergeTwoLists = function(l1, l2) {
        if(!l1 || !l2) return l1 || l2
        if(l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next,l2)
            return l1
        } else {
            l2.next = mergeTwoLists(l1,l2.next)
            return l2
        }
    }
</script>

<script>
    var sortList = function(head) {
        while(head && head.next) {
            var a = head.next,b = a.next
            while(a && b) {
                if(a.val > b.val) {
                    var tmp = b.next
                    b.next = a
                    a.next = tmp
                }
            }
        }
        return head
    }
</script>

<script>
    function mergeSort(ary) {

        if(ary.length < 2) return ary.slice()
        var mid = Math.floor(ary.length / 2)
        aryleft = ary.slice(0,mid)
        aryright = ary.slice(mid)
        mergeSort(aryleft)
        mergeSort(aryright)
        return merge(aryleft,aryright)
    }

    function merge(ary1,ary2) {
        var result = []
        var i = 0,j = 0
        while(i < ary1.length && j < ary2.length) {

            if(ary1[i] <= ary2[j]) {
                result.push(ary1[i])
                i++
            } else {
                result.push(ary2[j])
                j++               
            }
        }
        while(i < ary1.length) {
            result.push(ary1[i])
            i++
        }
        while(j < ary2.length) {
            result.push(ary2[j])
            j++
        }
        return result
    }
    mergeSort([5,4,3,2,1])
</script>


<script>
    var addTwoNumbers = function(l1, l2) {
        var sum = 0
        var head = new ListNode()
        var l3 = head
        while(l1 || l2 || sum) {
            if(l1) {
            sum += l1.val
            l1 = l1.next
            }
            if(l2) {
                sum += l2.val
                l2 = l2.next
            }
            l3.next = new ListNode(sum % 10)
            l3 = l3.next
            sum >= 10 ? sum = 1 : sum = 0 
        }
        return head.next
    }
</script>

<script>
    var addTwoNumbers = function(l1, l2) {
        var sum = 0,carry = 0
        var head = new ListNode()
        var l3 = head
        while(l1 || l2 || carry) {
            if(l1) {
            sum += l1.val
            l1 = l1.next
            }
            if(l2) {
                sum += l2.val
                l2 = l2.next
            }
            l3.next = new ListNode((sum + carry) % 10)
            l3 = l3.next
            carry = Math.floor((sum + carry) / 10)
            sum = 0
        }
        return head.next
    } 
</script>

<script>  //求后一半的链表
    var middleNode = function(head) {
        var list = head
        var count = 0
        while(list) {
            list = list.next
            count++
        }
        var mid = Math.floor(count / 2)
        var idx = 0
        while(idx !== mid - 1) {
            idx++
            head = head.next
        }
        return head
    }
</script>

<script>  //上题 快慢指针
    var middleNode = function(head) {
        var slow = head
        var fast = head
        while(fast && fast.next) {
            slow = slow.next
            fast = fast.next.next
        }
        return slow
    }
</script>

<script>  //反转列表  循环
    var reverseList = function(head) {
        var newHead = null
        while(list) {
            var tmp = head
            head = list.next
            tmp.next = newHead
            newHead = tmp
        }
        return newHead
    }
</script>

<script>  //反转列表  和上面的写法基本相同
    var reverseList = function(head) {
        var list = null
        while(head) {
            var tmp = head.next
            head.next = list
            list = head
            head = tmp
        }
        return list
    }
</script>

<script>  //递归 结果不对
    var reverseList = function(head) {
        var newlist = null
        if(head === null) return head
        var tmp = reverseList(head.next)
        head.next = newlist
        newlist = head
        head = tmp
        return newlist
    }
</script>

<script>  //递归 函数返回的是反转链表后的头节点
    var reverseList = function(head) {
        if(head == null || head.next == null) return head  //所以为空时返回的是null
        newHead = reverseList(head.next)
        head.next.next = head   //让反转前头节点的下一个节点指向头节点
        head.next = null
        return newHead 
    }
</script>

<script>  //删除指定节点
    var deleteNode = function(node) {
        node.val = node.next.val
        node.next = node.next.next 
    }
</script>

<script>  //删除多余节点
    var deleteDuplicates = function(head) {
        var list = head
        while(head && head.next) {
            if(head.val == head.next.val) {
                head.next = head.next.next
            }
            else {
                head = head.next
            }
        }
        return list
    }
</script>

<script>
    var getIntersectionNode = function(headA, headB) {
        while(headA && headA.next && headB && headB.next) {
            if(headA == headB) return headA
            headA = headA.next
            headB = headB.next
        }
        return null
    }
</script>

<script> //找两个链表的共同节点
    var getIntersectionNode = function(headA, headB) {
        if(!headA || !headB) return null
        var listA = headA,listB = headB
        while(listA !== listB) {
            listA = listA == null ? headB : listA.next
            listB = listB == null ? headA : listB.next
        }
        return listA
    }
</script>

<script>  //上题的常规解法
    var listA = headA, listB = headB
    var counta = 0,countb = 0
    while(listA || listB) {
        if(listA) {
            counta++
            listA = listA.next
        }
        if(listB) {
            countb++
            listB = listB.next
        }
    }
    if(counta > countb) {
        let rest = counta - countb
        for(let i = 0;i < rest;i++) {
            headA = headA.next
        }
    } else {
        let rest = countb - counta
        for(let i = 0;i < rest;i++) {
            headB = headB.next
        }        
    }
    while(headA && headB) {
        if(headA == headB) return headA
        headA = headA.next
        headB = headB.next
    }
    return null
</script>

<script>  //删除和指定值相等的链表节点
    var removeElements = function(head, val) {
        if(head === null) return head
        while(head && head.val === val) {
            head = head.next
        }
        var list = head
        while(list && list.next) {
            if(list.next.val === val) {
                list.next = list.next.next
            }
            else list = list.next
        }
        return head
    }
</script>
  
<script>   //删除和指定值相等的链表节点  别人的一种思路清奇的做法
    var removeElements = function(head, val) {
        var list = head
        var newlist = null
        while(list) {
            if(list.val == val) {
                if(newlist) {
                    newlist.next = list.next
                } else {
                    head = head.next
                }
            } else {
                newlist = list
            }
            list = list.next
        }
        return head
    }
</script>

<script>  //删除和指定值相等的链表节点 递归
    var removeElements = function(head, val) {
        if(!head) return null
        if(head.val === val) return removeElements(head.next,val)
        head.next = removeElements(head.next,val)
        return head
    }
</script>

<script>  //判断回文链表
    var isPalindrome = function(head) {
        if(head == null || head.next == null) return true
        var slow = head
        var fast = head
        while(fast && fast.next){
            slow = slow.next
            fast = fast.next.next
        }
        var last = reverseList(slow)
        
        while(last) {
            if(last.val !== head.val) return false
            last = last.next
            head = head.next
        }
        return true
    }

    var reverseList = function(head) {
        var list = null
        while(head) {
            tmp = head.next
            head.next = list
            list = head
            head = tmp
        }
        return list
    }
</script>

<script> 
    var reverseList = function(head) {
        var a = null
        var b = head,c = head
        while(b) {
            c = c.next
            b.next = a
            a = b
            b = c
        }
        return b
    }
</script>

<script>
    function removeElements(head, val) {
    if(head === null) return null
    if(head.val == val) return removeElements(head.next, val)
    head.next = removeElements(head.next, val)
    return head
    }
</script>

<script>  //24   递归
    var swapPairs = function(head) {
        if(!head || !head.next) return head
        var a = head,b = head.next,c = b.next
        b.next = a
        a.next = swapPairs(c)
        return b
    }
</script>

<script> //24  递归
    var swapPairs = function(head) {
        if(!head || !head.next) return head
        var a = head.next
        head.next = swapPairs(head.next.next)
        a.next = head
        return a
    }
</script>

<script>   //24 循环
    var swapPairs = function(head) {
        if(!head || !head.next) return head
        var dummy = new ListNode()
        var a = dummy,b = head,c = head.next,d = head.next.next
        while(true) {
            a.next = c
            b.next = d
            c.next = b
            if(!d || !d.next) return head
            a = b 
            b = d
            c = d.next
            d = c.next
        }
    }
</script>

<script>   //21合并两链表 递归
    var mergeTwoLists = function(l1, l2) {
        if(!l1 || !l2) return l1 || l2
        if(l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next,l2)
            return l1
        } else {
            l2.next = mergeTwoLists(l1,l2.next)
            return l2
        }
    }
</script>

<script>  //19
    var removeNthFromEnd = function(head, n) {
        var list = head,newlist = head
        var count = 0
        while(list) {
            list = list.next
            count++
        }
        s = n < count ? count - n : 0
        if(s == count - 1) {
            if(count === 1) return null
            while(newlist.next.next) {
                newlist = newlist.next
            }
            newlist.next = null
            return head
        }
        if(n === count) {
            head = head.next
            return head
        }
        var i = 0
        while(i != s - 1) {
            i++
            newlist = newlist.next
        }
        newlist.next = newlist.next.next
        return head
    }
</script>

<script>
    var removeNthFromEnd = function(head, n) {
    if(!head) return null
    var d = 0,deleted = false
    traverse(head)
    if(deleted) return head
    else return head.next

    function traverse(head) {
        if(head) {
            traverse(head.next)
            d++
            if(d == n + 1) {
                deleted = true
                head.next = head.next.next
            }
        }
    }
    }
</script>

<script>
    function mergeSort(ary) {
        if(ary.length < 2) return ary.slice()
        var mid = Math.floor(ary.length / 2)
        var aryleft = ary.slice(0,mid)
        var aryright = ary.slice(mid)
        aryleft = mergeSort(aryleft)
        aryright = mergeSort(aryright)
        return merge(aryleft,aryright)
    }

    function merge(ary1,ary2) {
        var result = []
        var i = 0,j = 0
        while(i < ary1.length && j < ary2.length) {

            if(ary1[i] <= ary2[j]) {
                result.push(ary1[i])
                i++
            } else {
                result.push(ary2[j])
                j++               
            }
        }
        while(i < ary1.length) {
            result.push(ary1[i])
            i++
        }
        while(j < ary2.length) {
            result.push(ary2[j])
            j++
        }
        return result
    }
    mergeSort([5,4,3,2,1])
</script>

<script>
    var flatten = function(head) {
        if(!head) return head
        if(head.child) {
            head.next = flatten(head.child)
            var newhead = flatten(head.child)
            while(newhead.next) {
                newhead = newhead.next
            }
            newhead.next = head
            return head
        }
    }
</script>

<script>
    var flatten = function(head) {
        if(!head) return head
        var p = head
        while(p) {
            if(p.child) {
                var c = flatten(p.child)
                var q = p.next
                p.next = c
                c.prev = p
                p.child = null
                while(c.next) {
                    c = c.next
                }
                if(q) {
                    c.next = q
                    q.prev = c                
                }
                p = c
            }
            p = p.next
        }
        return head
    }
</script>

<script>  //旋转部分链表 92
    var reverseBetween = function(head, m, n) {
        var dummy = new ListNode()
        dummy.next = head
        var p = dummy
        for(let i = 1;i < m;i++) {
            p = p.next
        }
        var tail = p.next
        for(let i = m;i < n;i++) {
            var tmp = p.next
            p.next = tail.next   
            p.next.next = tmp  
        }
        return dummy.next    
    }
</script>

<script>
    var numComponents = function(head, g) {
        var ary = []
        while(head) {
            ary.push(head.val)
            head = head.next
        }
        var judge = false,count = 0,i = 0
        while(i < ary.length) {
            while(g.indexOf(ary[i]) != -1) {
                i++
                judge = true
            }
            if(judge) count++
            judge = false
            i++
        }
        return count
    }
</script>

<script>
    var numComponents = function(head, g) {
        var judge = true
        var count = 0
        while(head) {
            if(g.include(head.val) && judge) {
                count++
                judge = false
            } else if (!g.include(head.val)) {
                judge = true
            }
            head = head.next
        }
        return count
    }
</script>

<script>
    var mergeKLists = function(lists) {
        if(!lists) return null
        var result = mergeTwoLists(l1,l2)
        while(lists.length > 1) {  
            var l1 = lists.shift()
            var l2 = lists.shift()
            result = mergeTwoLists(l1,l2)
            lists.push(result)
        }
        return result
    }

    var mergeTwoLists = function(l1, l2) {
        if(!l1 || !l2) return l1 || l2
        if(l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next,l2)
            return l1
        } else {
            l2.next = mergeTwoLists(l1,l2.next)
            return l2
        }
    }
</script>

<script>
    if(list.length == 0 || lists == null) return null
    else return mergeKList(lists,0,lists.length - 1)

    var mergeKList = function(lists,left,end) {
        if(left === right) return lists[left]
        else {
            var left = 0,right = lists.length - 1
            var mid = Math.floor((left + right) / 2)
            listleft = mergeKLists(lists,left,mid)
            listright = mergeKLists(lists,mid + 1,right)
            return mergeTwoLists(listleft,listright)
        }

    }

    var mergeTwoLists = function(l1, l2) {
        if(!l1 || !l2) return l1 || l2
        if(l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next,l2)
            return l1
        } else {
            l2.next = mergeTwoLists(l1,l2.next)
            return l2
        }
    }
</script>

<script>
    var mergeKLists = function(lists,left,end) {
        if(left === right) return lists[left]
        else {
            var left = 0,right = lists.length - 1
            var mid = Math.floor((left + right) / 2)
            listleft = mergeKLists(lists,left,mid)
            listright = mergeKLists(lists,mid + 1,right)
            return mergeTwoLists(listleft,listright)
        }
    }

    var mergeTwoLists = function(l1, l2) {
        if(!l1 || !l2) return l1 || l2
        if(l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next,l2)
            return l1
        } else {
            l2.next = mergeTwoLists(l1,l2.next)
            return l2
        }
    }
</script>

<script>
    var rotateRight = function(head, k) {
        if(head == null) return null
        var list = head
        var l = k % size(head)
        if(l === 0) return head
        var y = size(head) - l - 1
        for(let i = 0;i < y;i++) {
            list = list.next
        }
        var tail = list.next
        list.next = null
        var last = tail
        for(let i = 0;i < l - 1;i++) {
            last = last.next
        }
        last.next = head
        return tail
    }

    function size(list) { 
        var length = 0
        while(list) {
            length++
            list = list.next
        }
        return length
    }
</script>

<script>  //82 没做出来qaq
    var deleteDuplicates = function(head) {
        while(head && head.next) {
            let value = head.val
            let judge = false
            while(head.next && head.next.val == value) {
                judge = true
                head = head.next
            }
            if(judge) head = head.next
            if(!head || (head.val !== head.next.val)) break
        }
        let list = head.next
        while(list && list.next && list.next.next) {
            let value = list.next.val
            let judge = false
            while(list.next.next.val == value) {
                judge = true
                list.next = list.next.next
            }
            if(!judge) list = list.next
        }
        return head
    }
</script>

<script>  //82 别人的做法
    var deleteDuplicates = function(head) {
        var dummy = new ListNode()
        dummy.next = head
        var list = head
        var pre = dummy
        while(list && list.next) {
            while(list.next && list.val == list.next.val) {
                list = list.next
            }
            if(pre.next == list) {
                pre = pre.next
            } else {
                pre.next = list.next
            }
            list = list.next
        }
        return dummy.next
    }
</script>

<script>
    var partition = function(head, x) {
        var list = head
        var dummy1 = new ListNode()
        var dummy2 = new ListNode()
        var dummy1origin = dummy1
        var dummy2origin = dummy2
        while(list) {
            if(list.val < x) {
                dummy1.next = new ListNode(list.val)
                dummy1 = dummy1.next
            } else {
                dummy2.next = new ListNode(list.val)
                dummy2 = dummy2.next
            }
            list = list.next
        }
        dummy1.next = dummy2origin.next
        return dummy1origin.next
    }
    partition(arrayToList([6,4,3,1,5,2]),3)
</script>

<script>
    var partition = function(head, x) {
        var list = head
        var dummy1 = new ListNode()
        var dummy2 = new ListNode()
        var dummy1origin = dummy1
        var dummy2origin = dummy2
        while(head) {
            if(head.val < x) {
                dummy1.next = head
                dummy1 = dummy1.next 
            } else {
                dummy2.next = head
                dummy2 = dummy2.next
            }
            head = head.next
        }
        dummy2.next = null
        dummy1.next = dummy2.next
        return dummy1origin.next
    }
    partition(arrayToList([6,4,3,1,5,2]),3)
</script>

<script>
    var partition = function(head, x) {
        var dummy1 = new ListNode()
        var dummy2 = new ListNode()
        var dummy1origin = dummy1
        var dummy2origin = dummy2
        while(head) {
            var curr = head
            head = head.next
            curr.next = null
            if(curr.val < x) {
                dummy1.next = curr
                dummy1 = dummy1.next
            } else {
                dummy2.next = curr
                dummy2 = dummy2.next
            }
        }
        dummy1.next = dummy2origin.next
        return dummy1origin.next
    }
    partition(arrayToList([6,4,3,1,5,2]),3)
</script>

<script>
    var detectCycle = function(head) {
        var slow = head,fast = head,count = 0
        var isCycle = false
        while(fast !== null && fast.next !== null) {
            slow = slow.next
            fast = fast.next.next
            count++
            if(slow == fast) {
                isCycle = true
                break
            }
        }
        if(!isCycle) return null
        slow = head
        while(slow !== fast) {
            slow = slow.next
            fast = fast.next
        }
        return slow
    }

</script>

<script>
    var copyRandomList = function(head) {
    }
</script>

<script>
    var sortedListToBST = function(head) {
        let list = head
        let slow = head
        let fast = head
        let ary = []
        while(fast.next && fast.next.next) {
            slow = slow.next
            fast = fast.next.next
        }
        while(list != slow) {
            ary.push(list.val)
            list = list.next
        }
        let root = new TreeNode(slow.val)

    }
</script>

<script>  //109 二叉树转BST
    var sortedListToBST = function(head) {
        if(!head || !head.next) return head
        let list = head.next
        let slow = head
        let fast = head
        let half = new ListNode(head.val)
        let copy = half
        while(fast && fast.next) {
            slow = slow.next
            fast = fast.next.next
        }
        while(list && list != slow) {
            half.next = new ListNode(list.val)
            half = half.next
            list = list.next
        }
        let root = new TreeNode(slow.val)
        root.left = sortedListToBST(copy)
        root.right = sortedListToBST(slow.next)
        return root
    }
    sortedListToBST(arrayToList([0,1,2,3,4,5,6,7,8]))
</script>

<script>  //109 二叉树转BST  省空间的做法
    var sortedListToBST = function(head) {
        if(!head) return null
        return toBST(head,null)
    }

    function toBST(head,tail) {
        let slow = head
        let fast = head
        if(head == tail) return null
        while(fast !== tail && fast.next != tail) {
            slow = slow.next
            fast = fast.next.next
        }
        let root = new TreeNode(slow.val)
        root.left = toBST(head,slow)
        root.right = toBST(slow.next,tail)
        return root
    }
    sortedListToBST(arrayToList([-10,-3,0,5,9]))
</script>

<script>  //重排列表 143
    var reorderList = function(head) {
        if(!head || !head.next) return head
        let list = head
        let slow = head
        let fast = head
        while(fast.next && fast.next.next) {
            slow = slow.next
            fast = fast.next.next
        }
        let reverse = slow.next
        slow.next = null
        reverse = reverseList(reverse)
        while(list && reverse) {
            let secondList = list.next
            let secondReverse = reverse.next
            list.next = reverse
            reverse.next = secondList
            list = secondList
            reverse = secondReverse
        }
        return head
    }
    reorderList(arrayToList([1,2,3,4,5]))

    function reverseList(head) {
        if(!head || !head.next) return head
        let newHead = reverseList(head.next)
        head.next.next = head
        head.next = null
        return newHead
    }
</script>


<script>   //插入排序  147
    var insertionSortList = function(head) {
        let dummy = new ListNode()
        while(head) {
            let cur = dummy
            while(cur.next && head.val > cur.next.val) {
                cur = cur.next
            }
            let secondcur = cur.next
            cur.next = new ListNode(head.val)
            cur.next.next = secondcur
            head = head.next
        }
        return dummy.next
    }
</script>

<script>   //插入排序  147
    var insertionSortList = function(head) {
        let dummy = new ListNode()
        while(head) {
            let cur = dummy
            let t = head.next
            while(cur.next && head.val > cur.next.val) {
                cur = cur.next
            }
            let secondcur = cur.next
            cur.next = head
            head.next = secondcur
            head = t
        }
        return dummy.next
    }
</script>

<script>  //两数相加 457
    var addTwoNumbers = function(l1, l2) {
        let ary1 = []
        let ary2 = []
        let l3 = new ListNode()
        while(l1) {
            ary1.push(l1.val)
            l1 = l1.next
        }
        while(l2) {
            ary2.push(l2.val)
            l2 = l2.next
        }
        let t = 0
        while(ary1.length > 0 || ary2.length > 0) {
            let num1 = ary1.pop()
            num1 = num1 ? num1 : 0
            let num2 = ary2.pop()
            num2 = num2 ? num2 : 0
            let num = (num1 + num2 + t) % 10
            t = Math.floor((num1 + num2 + t) / 10)
            let tmp = new ListNode(num)
            if(l3.val) {
                tmp.next = l3
            }
            l3 = tmp
        }
        if(t > 0) {
            let tmp = new ListNode(t)
            tmp.next = l3
            l3 = tmp            
        }
        return l3
    }
    addTwoNumbers(arrayToList([7,2,4,3]),arrayToList([5,6,4]))
</script>

<script>  //分割链表 725
    var splitListToParts = function(root, k) {
        let result = []
        let l = size(root)
        let remain = l % k
        let number = (l - remain) / k
        for(let j = 0;j < k;j++) {
            let i = 1
            if(root) {
                var list = new ListNode(root.val)
            }
            else {
                var list = null
            }
            var newList = list
            if(root) root = root.next
            while(i < number && root) {
                list.next = new ListNode(root.val)
                list = list.next
                i++
                root = root.next
            }
            if(remain > 0 && number > 0 && root) {
                list.next = new ListNode(root.val)
                list = list.next
                i++
                root = root.next
                remain--
            }
            result.push(newList)
        }
        return result
    }
    splitListToParts(arrayToList([1,2,3,4,5,6,7,8,9,10,11,12,13]),5)

    function size(list) { 
        var length = 0
        while(list !== null) {    //while(list)
            length++
            list = list.next
        }
        return length
    }
</script>

<script>  //分割链表 725
    var splitListToParts = function(root, k) {
        let result = []
        let l = size(root)
        let t = k
        for(let i = 0;i < k;i++) {
            if(!root) {
                result.push(root)
            } else {
                result.push(root)
                let number = Math.ceil(l / t)
                for(let j = 1;j < number;j++) {
                    root = root.next
                }
                if(root) {
                    let newRoot = root.next
                    root.next = null
                    root = newRoot
                }
                l -= number
                t--
            }
        }
        return result
    }
    splitListToParts(arrayToList([1,2,3,4,5,6,7,8,9,10,11,12,13]),5)

    function size(list) { 
        var length = 0
        while(list !== null) {    //while(list)
            length++
            list = list.next
        }
        return length
    }
</script>

<script>   //奇偶链表 328
    var oddEvenList = function(head) {
        if(!head) return head
        let odd = head,even = head.next,evenHead = even
        while(even && even.next) {
            odd.next = even.next
            even.next = even.next.next
            odd = odd.next
            even = even.next
        }
        odd.next = evenHead
        return head
    }
</script>

<script>
    var nextLargerNodes = function(head) {
        let result = []
        while(head.next) {
            if(head.next.val > head.val) {
                result.push(head.next.val)
            } else {
                let list = head.next.next
                while(list && list.val <= head.val) {
                    list = list.next
                }
                let t = list ? list.val : 0
                result.push(t)
            }
            head = head.next
        }
        result.push(0)
        return result
    }
</script>

<script>
    var nextLargerNodes = function(head) {
        let result = []
        let stack = []
        while(head) {
            result.push(head.val)
            head = head.next
        }
        let n = result.length - 1
        while(n >= 0) {
            if(stack.length == 0) {
                stack.push(result[n])
                result[n] = 0
                n--
            } else if(result[n] < stack[stack.length - 1]) {
                let temp = stack[stack.length - 1]
                stack.push(result[n])
                result[n] = temp
                n--
            } else {
                stack.pop()
            }
        }
        return result
    }
    nextLargerNodes(arrayToList([1,7,5,1,9,2,5,1]))
</script>