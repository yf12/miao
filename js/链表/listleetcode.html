<script type = "x"> //数组转链表 递归 数组过长时栈会爆
    function arrayToList(ary, start = 0) {
        if(start == ary.length) return null
        var headNode = {
            val: ary[start],
            next: arrayToList(ary,++start)   
        }
        return headNode
    }
    arrayToList([0,1,2,3,4])
</script>

<script>
    function ListNode(val) {
        this.val = val
        this.next = null
    }
</script>

<script type = "x"> //141
    var hasCycle = function(head) {
        var slow = head,fast = head
        while(fast !== null && fast.next !== null) {
            slow = slow.next
            fast = fast.next.next
            if(slow == fast) return true
        }
        return false
    }
</script>

<script type = "x">  //链表合并  21
     var mergeTwoLists = function(l1, l2) {

        if(l1 === null || l2 === null) {
            return l1 === null ? l2 : l1
        }
        let merge = new ListNode()
        let l3 = merge
        if(l1.val <= l2.val) {
            l3.val = l1.val
            l1 = l1.next
        } else {
            l3.val = l2.val
            l2 = l2.next           
        }
        while(l1 || l2) {
            if( l2 === null || (l1 != null && l1.val < l2.val)) {  //左边为真返回左边
                l3.next = l1
                l1 = l1.next
            }
            else {
                l3.next = l2
                l2 = l2.next
            }
            l3 = l3.next  
        }
        return merge
    }
    mergeTwoLists(arrayToList([1,2,4]),arrayToList([1,3,4]))
</script>

<script type = "x">  //链表合并  21
    var mergeTwoLists = function(l1, l2) {
        var merge = {val: -1, next: null}
        var prev = merge
        while(l1 && l2) {
            if(l1.val >= l2.val) {
                prev.next = l2
                l2 = l2.next
            } else {
                prev.next = l1
                l1 = l1.next
            }
            prev = prev.next
        }
        prev.next = l1 || l2
        return merge.next
    }
</script>

<script>   //148 列表排序 需要dummy节点,在只有两个元素的时候链表右边为空，会无限递归
    var sortList = function(head) {
        if(!head || !head.next) return head
        var dummy = new ListNode()
        dummy.next = head
        var slow = dummy,fast = dummy
        while(fast && fast.next) {
            slow = slow.next
            fast = fast.next.next
        }
        var left = head,right = slow.next
        slow.next = null
        left = sortList(left)
        right = sortList(right)
        return mergeTwoLists(left,right)
    }

    var mergeTwoLists = function(l1, l2) {
        if(!l1 || !l2) return l1 || l2
        if(l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next,l2)
            return l1
        } else {
            l2.next = mergeTwoLists(l1,l2.next)
            return l2
        }
    }
</script>

<script>//148 列表排序 不需要dummy节点
    var sortList = function(head) {
        if(!head || !head.next) return head
        var slow = head,fast = head
        while(fast.next && fast.next.next) {
            slow = slow.next
            fast = fast.next.next
        }
        var left = head,right = slow.next
        slow.next = null
        left = sortList(left)
        right = sortList(right)
        return mergeTwoLists(left,right)
        }

    var mergeTwoLists = function(l1, l2) {
        if(!l1 || !l2) return l1 || l2
        if(l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next,l2)
            return l1
        } else {
            l2.next = mergeTwoLists(l1,l2.next)
            return l2
        }
    }
</script>

<script>
    var sortList = function(head) {
        while(head && head.next) {
            var a = head.next,b = a.next
            while(a && b) {
                if(a.val > b.val) {
                    var tmp = b.next
                    b.next = a
                    a.next = tmp
                }
            }
        }
        return head
    }
</script>

<script>
    function mergeSort(ary) {

        if(ary.length < 2) return ary.slice()
        var mid = Math.floor(ary.length / 2)
        aryleft = ary.slice(0,mid)
        aryright = ary.slice(mid)
        mergeSort(aryleft)
        mergeSort(aryright)
        return merge(aryleft,aryright)
    }

    function merge(ary1,ary2) {
        var result = []
        var i = 0,j = 0
        while(i < ary1.length && j < ary2.length) {

            if(ary1[i] <= ary2[j]) {
                result.push(ary1[i])
                i++
            } else {
                result.push(ary2[j])
                j++               
            }
        }
        while(i < ary1.length) {
            result.push(ary1[i])
            i++
        }
        while(j < ary2.length) {
            result.push(ary2[j])
            j++
        }
        return result
    }
    mergeSort([5,4,3,2,1])
</script>


<script>
    var addTwoNumbers = function(l1, l2) {
        var sum = 0
        var head = new ListNode()
        var l3 = head
        while(l1 || l2 || sum) {
            if(l1) {
            sum += l1.val
            l1 = l1.next
            }
            if(l2) {
                sum += l2.val
                l2 = l2.next
            }
            l3.next = new ListNode(sum % 10)
            l3 = l3.next
            sum >= 10 ? sum = 1 : sum = 0 
        }
        return head.next
    }
</script>

<script>
    var addTwoNumbers = function(l1, l2) {
        var sum = 0,carry = 0
        var head = new ListNode()
        var l3 = head
        while(l1 || l2 || carry) {
            if(l1) {
            sum += l1.val
            l1 = l1.next
            }
            if(l2) {
                sum += l2.val
                l2 = l2.next
            }
            l3.next = new ListNode((sum + carry) % 10)
            l3 = l3.next
            carry = Math.floor((sum + carry) / 10)
            sum = 0
        }
        return head.next
    } 
</script>

<script>  //求后一半的链表
    var middleNode = function(head) {
        var list = head
        var count = 0
        while(list) {
            list = list.next
            count++
        }
        var mid = Math.floor(count / 2)
        var idx = 0
        while(idx !== mid - 1) {
            idx++
            head = head.next
        }
        return head
    }
</script>

<script>  //上题 快慢指针
    var middleNode = function(head) {
        var slow = head
        var fast = head
        while(fast && fast.next) {
            slow = slow.next
            fast = fast.next.next
        }
        return slow
    }
</script>

<script>  //反转列表  循环
    var reverseList = function(head) {
        var newHead = null
        while(list) {
            var tmp = head
            head = list.next
            tmp.next = newHead
            newHead = tmp
        }
        return newHead
    }
</script>

<script>  //反转列表  和上面的写法基本相同
    var reverseList = function(head) {
        var list = null
        while(head) {
            var tmp = head.next
            head.next = list
            list = head
            head = tmp
        }
        return list
    }
</script>

<script>  //递归 结果不对
    var reverseList = function(head) {
        var newlist = null
        if(head === null) return head
        var tmp = reverseList(head.next)
        head.next = newlist
        newlist = head
        head = tmp
        return newlist
    }
</script>

<script>  //递归 函数返回的是反转链表后的头节点
    var reverseList = function(head) {
        if(head == null || head.next == null) return head  //所以为空时返回的是null
        newHead = reverseList(head.next)
        head.next.next = head   //让反转前头节点的下一个节点指向头节点
        head.next = null
        return newHead 
    }
</script>

<script>  //删除指定节点
    var deleteNode = function(node) {
        node.val = node.next.val
        node.next = node.next.next 
    }
</script>

<script>  //删除多余节点
    var deleteDuplicates = function(head) {
        var list = head
        while(head && head.next) {
            if(head.val == head.next.val) {
                head.next = head.next.next
            }
            else {
                head = head.next
            }
        }
        return list
    }
</script>

<script>
    var getIntersectionNode = function(headA, headB) {
        while(headA && headA.next && headB && headB.next) {
            if(headA == headB) return headA
            headA = headA.next
            headB = headB.next
        }
        return null
    }
</script>

<script> //找两个链表的共同节点
    var getIntersectionNode = function(headA, headB) {
        if(!headA || !headB) return null
        var listA = headA,listB = headB
        while(listA !== listB) {
            listA = listA == null ? headB : listA.next
            listB = listB == null ? headA : listB.next
        }
        return listA
    }
</script>

<script>  //上题的常规解法
    var listA = headA, listB = headB
    var counta = 0,countb = 0
    while(listA || listB) {
        if(listA) {
            counta++
            listA = listA.next
        }
        if(listB) {
            countb++
            listB = listB.next
        }
    }
    if(counta > countb) {
        let rest = counta - countb
        for(let i = 0;i < rest;i++) {
            headA = headA.next
        }
    } else {
        let rest = countb - counta
        for(let i = 0;i < rest;i++) {
            headB = headB.next
        }        
    }
    while(headA && headB) {
        if(headA == headB) return headA
        headA = headA.next
        headB = headB.next
    }
    return null
</script>

<script>  //删除和指定值相等的链表节点
    var removeElements = function(head, val) {
        if(head === null) return head
        while(head && head.val === val) {
            head = head.next
        }
        var list = head
        while(list && list.next) {
            if(list.next.val === val) {
                list.next = list.next.next
            }
            else list = list.next
        }
        return head
    }
</script>
  
<script>   //删除和指定值相等的链表节点  别人的一种思路清奇的做法
    var removeElements = function(head, val) {
        var list = head
        var newlist = null
        while(list) {
            if(list.val == val) {
                if(newlist) {
                    newlist.next = list.next
                } else {
                    head = head.next
                }
            } else {
                newlist = list
            }
            list = list.next
        }
        return head
    }
</script>

<script>  //删除和指定值相等的链表节点 递归
    var removeElements = function(head, val) {
        if(!head) return null
        if(head.val === val) return removeElements(head.next,val)
        head.next = removeElements(head.next,val)
        return head
    }
</script>

<script>  //判断回文链表
    var isPalindrome = function(head) {
        if(head == null || head.next == null) return true
        var slow = head
        var fast = head
        while(fast && fast.next){
            slow = slow.next
            fast = fast.next.next
        }
        var last = reverseList(slow)
        
        while(last) {
            if(last.val !== head.val) return false
            last = last.next
            head = head.next
        }
        return true
    }

    var reverseList = function(head) {
        var list = null
        while(head) {
            tmp = head.next
            head.next = list
            list = head
            head = tmp
        }
        return list
    }
</script>

<script> 
    var reverseList = function(head) {
        var a = null
        var b = head,c = head
        while(b) {
            c = c.next
            b.next = a
            a = b
            b = c
        }
        return b
    }
</script>

<script>
    function removeElements(head, val) {
    if(head === null) return null
    if(head.val == val) return removeElements(head.next, val)
    head.next = removeElements(head.next, val)
    return head
    }
</script>

<script>  //24   递归
    var swapPairs = function(head) {
        if(!head || !head.next) return head
        var a = head,b = head.next,c = b.next
        b.next = a
        a.next = swapPairs(c)
        return b
    }
</script>

<script> //24  递归
    var swapPairs = function(head) {
        if(!head || !head.next) return head
        var a = head.next
        head.next = swapPairs(head.next.next)
        a.next = head
        return a
    }
</script>

<script>   //24 循环
    var swapPairs = function(head) {
        if(!head || !head.next) return head
        var dummy = new ListNode()
        var a = dummy,b = head,c = head.next,d = head.next.next
        while(true) {
            a.next = c
            b.next = d
            c.next = b
            if(!d || !d.next) return head
            a = b 
            b = d
            c = d.next
            d = c.next
        }
    }
</script>

<script>   //21合并两链表 递归
    var mergeTwoLists = function(l1, l2) {
        if(!l1 || !l2) return l1 || l2
        if(l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next,l2)
            return l1
        } else {
            l2.next = mergeTwoLists(l1,l2.next)
            return l2
        }
    }
</script>

<script>  //19
    var removeNthFromEnd = function(head, n) {
        var list = head,newlist = head
        var count = 0
        while(list) {
            list = list.next
            count++
        }
        s = n < count ? count - n : 0
        if(s == count - 1) {
            if(count === 1) return null
            while(newlist.next.next) {
                newlist = newlist.next
            }
            newlist.next = null
            return head
        }
        if(n === count) {
            head = head.next
            return head
        }
        var i = 0
        while(i != s - 1) {
            i++
            newlist = newlist.next
        }
        newlist.next = newlist.next.next
        return head
    }
</script>

<script>
    var removeNthFromEnd = function(head, n) {
    if(!head) return null
    var d = 0,deleted = false
    traverse(head)
    if(deleted) return head
    else return head.next

    function traverse(head) {
        if(head) {
            traverse(head.next)
            d++
            if(d == n + 1) {
                deleted = true
                head.next = head.next.next
            }
        }
    }
    }
</script>

<script>
    function mergeSort(ary) {
        if(ary.length < 2) return ary.slice()
        var mid = Math.floor(ary.length / 2)
        var aryleft = ary.slice(0,mid)
        var aryright = ary.slice(mid)
        aryleft = mergeSort(aryleft)
        aryright = mergeSort(aryright)
        return merge(aryleft,aryright)
    }

    function merge(ary1,ary2) {
        var result = []
        var i = 0,j = 0
        while(i < ary1.length && j < ary2.length) {

            if(ary1[i] <= ary2[j]) {
                result.push(ary1[i])
                i++
            } else {
                result.push(ary2[j])
                j++               
            }
        }
        while(i < ary1.length) {
            result.push(ary1[i])
            i++
        }
        while(j < ary2.length) {
            result.push(ary2[j])
            j++
        }
        return result
    }
    mergeSort([5,4,3,2,1])
</script>

<script>
    var flatten = function(head) {
        if(!head) return head
        if(head.child) {
            head.next = flatten(head.child)
            var newhead = flatten(head.child)
            while(newhead.next) {
                newhead = newhead.next
            }
            newhead.next = head
            return head
        }
    }
</script>

<script>
    var flatten = function(head) {
        if(!head) return head
        var p = head
        while(p) {
            if(p.child) {
                var c = flatten(p.child)
                var q = p.next
                p.next = c
                c.prev = p
                p.child = null
                while(c.next) {
                    c = c.next
                }
                if(q) {
                    c.next = q
                    q.prev = c                
                }
                p = c
            }
            p = p.next
        }
        return head
    }
</script>

<script>  //旋转部分链表 92
    var reverseBetween = function(head, m, n) {
        var dummy = new ListNode()
        dummy.next = head
        var p = dummy
        for(let i = 1;i < m;i++) {
            p = p.next
        }
        var tail = p.next
        for(let i = m;i < n;i++) {
            var tmp = p.next
            p.next = tail.next   
            p.next.next = tmp  
        }
        return dummy.next    
    }
</script>

<script>
    var numComponents = function(head, g) {
        var ary = []
        while(head) {
            ary.push(head.val)
            head = head.next
        }
        var judge = false,count = 0,i = 0
        while(i < ary.length) {
            while(g.indexOf(ary[i]) != -1) {
                i++
                judge = true
            }
            if(judge) count++
            judge = false
            i++
        }
        return count
    }
</script>

<script>
    var numComponents = function(head, g) {
        var judge = true
        var count = 0
        while(head) {
            if(g.include(head.val) && judge) {
                count++
                judge = false
            } else if (!g.include(head.val)) {
                judge = true
            }
            head = head.next
        }
        return count
    }
</script>

<script>
    var mergeKLists = function(lists) {
        if(!lists) return null
        var result = mergeTwoLists(l1,l2)
        while(lists.length > 1) {  
            var l1 = lists.shift()
            var l2 = lists.shift()
            result = mergeTwoLists(l1,l2)
            lists.push(result)
        }
        return result
    }

    var mergeTwoLists = function(l1, l2) {
        if(!l1 || !l2) return l1 || l2
        if(l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next,l2)
            return l1
        } else {
            l2.next = mergeTwoLists(l1,l2.next)
            return l2
        }
    }
</script>

<script>
    if(list.length == 0 || lists == null) return null
    else return mergeKList(lists,0,lists.length - 1)

    var mergeKList = function(lists,left,end) {
        if(left === right) return lists[left]
        else {
            var left = 0,right = lists.length - 1
            var mid = Math.floor((left + right) / 2)
            listleft = mergeKLists(lists,left,mid)
            listright = mergeKLists(lists,mid + 1,right)
            return mergeTwoLists(listleft,listright)
        }

    }

    var mergeTwoLists = function(l1, l2) {
        if(!l1 || !l2) return l1 || l2
        if(l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next,l2)
            return l1
        } else {
            l2.next = mergeTwoLists(l1,l2.next)
            return l2
        }
    }
</script>

<script>
    var mergeKLists = function(lists,left,end) {
        if(left === right) return lists[left]
        else {
            var left = 0,right = lists.length - 1
            var mid = Math.floor((left + right) / 2)
            listleft = mergeKLists(lists,left,mid)
            listright = mergeKLists(lists,mid + 1,right)
            return mergeTwoLists(listleft,listright)
        }
    }

    var mergeTwoLists = function(l1, l2) {
        if(!l1 || !l2) return l1 || l2
        if(l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next,l2)
            return l1
        } else {
            l2.next = mergeTwoLists(l1,l2.next)
            return l2
        }
    }
</script>

<script>
    var rotateRight = function(head, k) {
        if(head == null) return null
        var list = head
        var l = k % size(head)
        if(l === 0) return head
        var y = size(head) - l - 1
        for(let i = 0;i < y;i++) {
            list = list.next
        }
        var tail = list.next
        list.next = null
        var last = tail
        for(let i = 0;i < l - 1;i++) {
            last = last.next
        }
        last.next = head
        return tail
    }

    function size(list) { 
        var length = 0
        while(list) {
            length++
            list = list.next
        }
        return length
    }
</script>

<script>  //82
    var deleteDuplicates = function(head) {
        if(!head) return head
        while(head && head.next) {
            let value = head.val
            let judge = false
            while(head.next && head.next.val == value) {
                judge = true
                head = head.next
            }
            if(judge) head = head.next
            if(head.val !== head.next.val) break
        }
        let list = head
        while(list.next && list.next.next) {
            let value = list.next.val
            let judge = false
            while(list.next.next.val == value) {
                judge = true
                list.next = list.next.next
            }
            if(judge) list.next = list.next.next
            list = list.next
        }
        return head
    }
</script>

<script>  //82
    var deleteDuplicates = function(head) {
        if(!head) return head
        while(head && head.next) {
            let value = head.val
            let judge = false
            while(head.next && head.next.val == value) {
                judge = true
                head = head.next
            }
            if(judge) head = head.next
            if(head.val !== head.next.val) break
        }
        return head
    }
</script>