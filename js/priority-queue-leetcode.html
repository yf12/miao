<script>  //找出堆中的第k个元素
    /**
    * @param {number} k
    * @param {number[]} nums
    */
    class KthLargest {
        constructor(k, nums){
            this.heap = new PriorityQueue(nums, it => -it)
        }
        add(val) {
            if (this.heap.peek() < val) {
                this.heap.pop()
                this.heap.push(val)
            } else {

            }
            return this.heap.peek()
        }
    }

    var KthLargest = function(k, nums) {
        function swap(ary, i, j) {
            var t = ary[i]
            ary[i] = ary[j]
            ary[j] = t
        }

        function heapDown(ary, currIdx, end = ary.length) {
            if (currIdx < end) {
                var maxIdx = currIdx
                var lIdx = currIdx * 2 + 1
                var rIdx = lIdx + 1
                if (lIdx < end && ary[lIdx] < ary[maxIdx]) {
                    maxIdx = lIdx
                }
                if (rIdx < end && ary[rIdx] < ary[maxIdx]) {
                    maxIdx = rIdx
                }
                if (currIdx !== maxIdx) {
                    swap(ary, currIdx, maxIdx)
                    heapDown(ary, maxIdx, end)
                }
            }
        }

        function heapify(ary) {
            var startIdx = (ary.length - 2) >> 1
            for(var i = startIdx; i >= 0; i--) {
                heapDown(ary, i)
            }
            return ary
        }

        let ary = []
        for(let i = 0;i < k;i++) {
            ary[i] = nums[i]
        }

        this.q = heapify(ary)

        for(let i = k;i < nums.length;i++) {
            add(nums[k])
        }
        this.q = q
    };

    /** 
    * @param {number} val
    * @return {number}
    */
    KthLargest.prototype.add = function(val) {
        if(val <= q[0]) {
            return q[0]
        } else {
            q[0] = val
            heapify(q)
        }
        return q[0]
    };
</script>